<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Adorkable Dean]]></title>
  <link href="http://adorkabledean.github.io/atom.xml" rel="self"/>
  <link href="http://adorkabledean.github.io/"/>
  <updated>2015-11-10T17:58:00+08:00</updated>
  <id>http://adorkabledean.github.io/</id>
  <author>
    <name><![CDATA[Adorkable Dean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Method Swizzling和分类的妙用--从AppDelegate轻量化处理说起]]></title>
    <link href="http://adorkabledean.github.io/blog/20151109/method-swizzlinghe-fen-lei-de-miao-yong-cong-appdelegateqing-liang-hua-chu-li-shuo-qi/"/>
    <updated>2015-11-09T21:23:43+08:00</updated>
    <id>http://adorkabledean.github.io/blog/20151109/method-swizzlinghe-fen-lei-de-miao-yong-cong-appdelegateqing-liang-hua-chu-li-shuo-qi</id>
    <content type="html"><![CDATA[<h1>Method Swizzling和分类的妙用&ndash;从AppDelegate轻量化处理说起</h1>

<ul>
<li>简介</li>
<li>函数模块化</li>
<li>类模块化</li>
<li>分类模块化</li>
<li>Method Swizzling化</li>
<li>参考文章</li>
</ul>


<p><img src="http://jbcdn2.b0.upaiyun.com/2014/02/48651426c0cd13af3f64447c7c24f648.png" alt="" /></p>

<h2>简介</h2>

<p>在iOS工程中，AppDelegate往往会有上千行，甚至几千行，这样就会给维护AppDelegate带来诸多麻烦。比方说，老板想在出现HomeViewController之前弹出广告并停顿几秒，这样你就要加入插入广告的逻辑；又比方说，老板想在开始做个请求，判断某个开关是否打开。这样就会在AppDelegate中插入很多相关的不相关的代码。</p>

<p>在AppDelegate中，<code>- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions</code>是<strong>&ldquo;Tells the delegate when the application has launched and may have additional launch options to handle.&rdquo;</strong>，即在app开始运行时会调用里面的方法。在<code>didFinishLaunchingWithOptions</code>中，我们往往会渲染window，注册第三方监控库，加入基本页面跳转逻辑。</p>

<p>下面是一个常见项目中的<code>didFinishLaunchingWithOptions</code>：</p>

<pre>
<code>
// objective-c语言
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
        
    if (!([ADeanUserDataManager sharedManager].userName != nil &&
          [ADeanUserDataManager sharedManager].userName.length > 0 &&
          [ADeanUserDataManager sharedManager].userPassword != nil &&
          [ADeanUserDataManager sharedManager].userPassword.length > 0)) {
        
        // 用户名、密码为空时候强制为未登录
        [ADeanUserDataManager sharedManager].isUserLogined = @NO;
    }
    
    self.window.rootViewController = self.tabbarController;
    [self.window makeKeyAndVisible];
    
    //  基本页面跳转逻辑
    /*--------------------------------------*/
    if ([[ADeanUserDataManager sharedManager].everLaunched boolValue] == NO) {
    //是否是第一次启动判断
        [ADeanUserDataManager sharedManager].everLaunched = [NSNumber numberWithBool:YES];
        [self.window addSubview:self.helpViewController.view];
    }
    /*--------------------------------------*/

    
    //  注册第三方库 
    /*--------------------------------------*/
    // 注册Crash统计 -- Crashlytics
    [Fabric with:@[[Crashlytics class]]];
    [MobClick startWithAppkey:UMENG_APPKEY];
    [MobClick setCrashReportEnabled:NO]; // 关掉MobClick Crash Report收集开关
#ifdef ADeanForTest
    [MobClick setCrashReportEnabled:YES]; // 打开MobClick Crash Report收集开关
    [MobClick setLogEnabled:YES];
#endif
    
    [ShareSDK registerApp:ShareSDKAppKey];
    
    //新浪
    [ShareSDK connectSinaWeiboWithAppKey:SinaAppKey
                               appSecret:SinaAppSecret
                             redirectUri:SinaRedirectUri];
    
    //新浪微博客户端应用
    [ShareSDK connectSinaWeiboWithAppKey:SinaAppKey
                               appSecret:SinaAppSecret
                             redirectUri:SinaRedirectUri
                             weiboSDKCls:[WeiboSDK class]];
    
#if TARGET_IPHONE_SIMULATOR
#else
    //QQ好友
    [ShareSDK connectQQWithQZoneAppKey:QZoneAppKey
                     qqApiInterfaceCls:[QQApiInterface class]
                       tencentOAuthCls:[TencentOAuth class]];
#endif
    //微信朋友圈
    [ShareSDK connectWeChatSessionWithAppId:WeiXinAppID wechatCls:[WXApi class]];
    //微信好友
    [ShareSDK connectWeChatTimelineWithAppId:WeiXinAppID wechatCls:[WXApi class]];

    [MiPushSDK registerMiPush:self type:(UIRemoteNotificationTypeBadge |
                                         UIRemoteNotificationTypeSound |
                                         UIRemoteNotificationTypeAlert) connect:YES];
    /*--------------------------------------*/
                                         
    //  其他逻辑
    [self registerRemotePushNotification];
    [self getSwitchInfoFromService];
    [self appIntegrityCheck];
    [self appSecurityCheck]
    ......
    
    return YES;
}
</code>
</pre>


<p>下面我们就来看看，有什么好的办法可以对AppDelegate进行瘦身，加强代码的可读性和可维护性，并将代码放到适当的地方。</p>

<h2>函数模块化</h2>

<p>上述<code>didFinishLaunchingWithOptions</code>中可以按照功能逻辑划分为：处理启动逻辑，注册第三方库，处理其他逻辑三类。这样就可以优化为：</p>

<pre>
<code>
// objective-c语言
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
        
    if (!([ADeanUserDataManager sharedManager].userName != nil &&
          [ADeanUserDataManager sharedManager].userName.length > 0 &&
          [ADeanUserDataManager sharedManager].userPassword != nil &&
          [ADeanUserDataManager sharedManager].userPassword.length > 0)) {
        
        // 用户名、密码为空时候强制为未登录
        [ADeanUserDataManager sharedManager].isUserLogined = @NO;
    }
    
    self.window.rootViewController = self.tabbarController;
    [self.window makeKeyAndVisible];
    
    //  基本页面跳转逻辑
    [self baseViewJumpLogic];
    //  注册第三方库 
    [self registThirdPart];                     
    //  其他逻辑
    [self handleOtherLogic]
    
    return YES;
}

- (void)baseViewJumpLogic {

    if ([[ADeanUserDataManager sharedManager].everLaunched boolValue] == NO) {
    //是否是第一次启动判断
        [ADeanUserDataManager sharedManager].everLaunched = [NSNumber numberWithBool:YES];
        [self.window addSubview:self.helpViewController.view];
    }
}

- (void)registThirdPart {
    // 注册Crash统计 -- Crashlytics
    [Fabric with:@[[Crashlytics class]]];
    [MobClick startWithAppkey:UMENG_APPKEY];
    [MobClick setCrashReportEnabled:NO]; // 关掉MobClick Crash Report收集开关
#ifdef ADeanForTest
    [MobClick setCrashReportEnabled:YES]; // 打开MobClick Crash Report收集开关
    [MobClick setLogEnabled:YES];
#endif
    
    [ShareSDK registerApp:ShareSDKAppKey];
    
    //新浪
    [ShareSDK connectSinaWeiboWithAppKey:SinaAppKey
                               appSecret:SinaAppSecret
                             redirectUri:SinaRedirectUri];
    
    //新浪微博客户端应用
    [ShareSDK connectSinaWeiboWithAppKey:SinaAppKey
                               appSecret:SinaAppSecret
                             redirectUri:SinaRedirectUri
                             weiboSDKCls:[WeiboSDK class]];
    
#if TARGET_IPHONE_SIMULATOR
#else
    //QQ好友
    [ShareSDK connectQQWithQZoneAppKey:QZoneAppKey
                     qqApiInterfaceCls:[QQApiInterface class]
                       tencentOAuthCls:[TencentOAuth class]];
#endif
    //微信朋友圈
    [ShareSDK connectWeChatSessionWithAppId:WeiXinAppID wechatCls:[WXApi class]];
    //微信好友
    [ShareSDK connectWeChatTimelineWithAppId:WeiXinAppID wechatCls:[WXApi class]];

    [MiPushSDK registerMiPush:self type:(UIRemoteNotificationTypeBadge |
                                         UIRemoteNotificationTypeSound |
                                         UIRemoteNotificationTypeAlert) connect:YES];
}

- (void)handleOtherLogic {
    [self registerRemotePushNotification];
    [self getSwitchInfoFromService];
    [self appIntegrityCheck];
    [self appSecurityCheck]
    ......
}
</code>
</pre>


<p>模块化后，代码瞬间变得易读很多，而且需要改什么可以直接去相应的模块添加。但是这个仅仅是将代码的顺序变化下，相同功能的代码抽到一个函数中，代码行数没有减少，所有的功能还是糅合在一个.m中。</p>

<h2>类模块化</h2>

<p>很多其他逻辑是业务逻辑的，可以抽离到业务Model中，通过类模块化便捷使用。这样就可以优化为：</p>

<pre>
<code>
// objective-c语言
#import "ADeanAppCheck.h"
#import "ADeanSwitches.h"
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
        
    if (!([ADeanUserDataManager sharedManager].userName != nil &&
          [ADeanUserDataManager sharedManager].userName.length > 0 &&
          [ADeanUserDataManager sharedManager].userPassword != nil &&
          [ADeanUserDataManager sharedManager].userPassword.length > 0)) {
        
        // 用户名、密码为空时候强制为未登录
        [ADeanUserDataManager sharedManager].isUserLogined = @NO;
    }
    
    self.window.rootViewController = self.tabbarController;
    [self.window makeKeyAndVisible];
    
    //  基本页面跳转逻辑
    [self baseViewJumpLogic];
    //  注册第三方库 
    [self registThirdPart];                     
    //  其他逻辑
    [self handleOtherLogic]
    
    return YES;
}

- (void)handleOtherLogic {
    [ADeanAppCheck appInfoCheck]; // Integrity & Security Check
    [ADeanSwitches appSwitchInit];  // Get Switch From Service 
    ......
}
</code>
</pre>


<h2>分类模块化</h2>

<p>先抛个问题：分类中是否可以定义变量？</p>

<p>如果不知道可以参考：<a href="http://www.jianshu.com/p/0ca0bbb0b200">iOS分类中通过runtime添加动态属性</a></p>

<p>分类能够做到的事情主要是：即使在你不知道一个类的源码情况下，向这个类添加扩展的方法。这里我们主要是将对外开放的方法和一部分变量拿到分类中处理。这样进一步轻量化AppDelegate本身进行代码量。</p>

<pre>
<code>
// objective-c语言
// ADeanAppDelegate+Light.h文件
#import "AppDelegate.h"
@interface ADeanAppDelegate (Light)

@property (nonatomic, strong) UITabbarController *tabbarController;

/*!
 @brief 全局appDeleaget
 */
+ (AppDelegate *)appDelegate;

/*!
 @method
 @brief 关闭系统键盘
 */
+ (void)closeKeyWindow;

@end
</code>
</pre>




<pre>
<code>
// objective-c语言
// ADeanAppDelegate+Light.m文件
#import "ADeanAppDelegate+Light.h"
- (UITabbarController *)tabbarController {
    UITabbarController *tabbarController = objc_getAssociatedObject(self, &kTabbarControllerObjectKey);
    if (!tabbarController) {
        tabbarController = [[UITabbarController alloc] init];
        objc_setAssociatedObject(self, &kTabbarControllerObjectKey, tabbarController, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return tabbarController;
}
- (void)setTabbarController:(UITabbarController *)tabbarController {
    objc_setAssociatedObject(self, &kTabbarControllerObjectKey, tabbarController, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

+ (AppDelegate *)appDelegate {
    return (AppDelegate *)[[UIApplication sharedApplication] delegate];
}

+ (void)closeKeyWindow {
    [[UIApplication sharedApplication].keyWindow endEditing:YES];
}
</code>
</pre>


<p>这样在AppDelegate中，对外开放的方法和部分变量可以抽离到分类中去。也可以根据作用定义不同的AppDelegate分类：</p>

<p><code>#&ldquo;ADeanAppDelegate+View.h&rdquo;</code></p>

<p><code>#&ldquo;ADeanAppDelegate+Controller.h&rdquo;</code></p>

<p><code>#&ldquo;ADeanAppDelegate+Method.h&rdquo;</code></p>

<p>&hellip;</p>

<p>这样代码结构会更加清晰明了。
抽出来的AppDelegate只剩下注册第三方库了，因为第三方库很多是需要在<code>didFinishLaunchingWithOptions</code>中运行，正常的方法就很难。</p>

<h2>Method Swizzling化</h2>

<p>Method Swizzling是改变一个selector的实际实现的技术，关于Method Swizzling的概念、原理谷歌一堆。</p>

<blockquote><p><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>中以viewWillAppear为例，讲解了Method Swizzling的基本用法。</p></blockquote>

<pre>
<code>
#import "ADeanAppDelegate+Hook.h"
#import "ADeanMethodSwizzling.h"
#import "MobClick.h"
#import "WXApi.h"
#import "WeiboSDK.h"
#import <Fabric/Fabric.h>
#import <Crashlytics/Crashlytics.h>
#import <ShareSDK/ShareSDK.h>
#if TARGET_IPHONE_SIMULATOR

#else
#import <TencentOpenAPI/QQApi.h>
#import <TencentOpenAPI/QQApiInterface.h>
#import <TencentOpenAPI/TencentOAuth.h>
#endif


@implementation ADeanAppDelegate (Hook)

+ (void)initialize
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        [self adean_AppDelegateHook];
    });
}

+ (void)adean_AppDelegateHook
{
    SwizzlingMethod([ADeanAppDelegate class], @selector(application:didFinishLaunchingWithOptions:), @selector(adean_application:didFinishLaunchingWithOptions:));
    SwizzlingMethod([ADeanAppDelegate class], @selector(application:handleOpenURL:), @selector(adean_application:handleOpenURL:));
    SwizzlingMethod([ADeanAppDelegate class], @selector(application:openURL:sourceApplication:annotation:), @selector(adean_application:openURL:sourceApplication:annotation:));
    SwizzlingMethod([ADeanAppDelegate class], @selector(applicationDidReceiveMemoryWarning:), @selector(adean_applicationDidReceiveMemoryWarning:));

}

#pragma mark - Method Swizzling

- (BOOL)adean_application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 耗时的操作
        // 注册Crash统计 -- Crashlytics
        [Fabric with:@[[Crashlytics class]]];
        
        // 友盟统计
        [MobClick startWithAppkey:UMENG_APPKEY];
        [MobClick setCrashReportEnabled:NO]; // 关掉MobClick Crash Report收集开关
#ifdef ADeanForTest
        [MobClick setCrashReportEnabled:YES]; // 打开MobClick Crash Report收集开关
        [MobClick setLogEnabled:YES];
#endif
        
        
        [ShareSDK registerApp:ShareSDKAppKey];
        
        //新浪
        [ShareSDK connectSinaWeiboWithAppKey:SinaAppKey
                                   appSecret:SinaAppSecret
                                 redirectUri:SinaRedirectUri];
        
        //新浪微博客户端应用
        [ShareSDK connectSinaWeiboWithAppKey:SinaAppKey
                                   appSecret:SinaAppSecret
                                 redirectUri:SinaRedirectUri
                                 weiboSDKCls:[WeiboSDK class]];
        
#if TARGET_IPHONE_SIMULATOR
#else
        //QQ好友
        [ShareSDK connectQQWithQZoneAppKey:QZoneAppKey
                         qqApiInterfaceCls:[QQApiInterface class]
                           tencentOAuthCls:[TencentOAuth class]];
#endif
        //微信朋友圈
        [ShareSDK connectWeChatSessionWithAppId:WeiXinAppID wechatCls:[WXApi class]];
        //微信好友
        [ShareSDK connectWeChatTimelineWithAppId:WeiXinAppID wechatCls:[WXApi class]];

    });



    return [self adean_application:application didFinishLaunchingWithOptions:launchOptions];
}


- (BOOL)adean_application:(UIApplication *)application handleOpenURL:(NSURL *)url
{
    [ShareSDK handleOpenURL:url wxDelegate:self];
    return [self adean_application:application handleOpenURL:url];
}

- (BOOL)adean_application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
{
    [ShareSDK handleOpenURL:url sourceApplication:sourceApplication annotation:annotation wxDelegate:self];
    return [self adean_application:application openURL:url sourceApplication:sourceApplication annotation:annotation];
}

-  (void)adean_applicationDidReceiveMemoryWarning:(UIApplication *)application {
    
    [self adean_applicationDidReceiveMemoryWarning:application];
}

@end

</code>
</pre>


<p>这下再去看下<code>AppDelegate</code>文件，代码不超过200行了。</p>

<h2>小结</h2>

<h4>Method Swizzling常见的应用场景：</h4>

<p>1，用于记录或者存储，比方说记录ViewController进入次数、Btn的点击事件、ViewController的停留时间等等。
可以通过Runtime获取到具体ViewController、Btn信息，然后传给服务器。</p>

<p>2，添加需要而系统没提供的方法，比方说修改Statusbar颜色。</p>

<p>3，用于轻量化、模块化处理，如上面介绍的，代码轻量化处理。</p>

<p>Method Swizzling是把双刃剑，需要正确理解它的使用。</p>

<h4>分类增加变量的使用场景：</h4>

<p>1，过多继承时，可以通过分类减少继承层级，清晰流程框架。比方说，ViewController可能需要相互冲突的事件，单一父类会导致逻辑复杂。这时候可以通过分类简化逻辑，不同的ViewController引用不同的分类。</p>

<p>2，扩展类属性。</p>

<p><br>
<strong>上面我们学习了一些瘦身的技巧，希望通过这些方法写出更可读性更高，可维护性更高的代码。</strong></p>

<p><br></p>

<h6>提醒：</h6>

<p>本文涉及到的<a href="https://github.com/AdorkableDean/iOSReadNoteDemo">Demo</a>已经放到GitHub上了。<em>Demo可能与本文有点出入，部分函数命名跟文章中不一致。</em></p>

<p><br><br><br></p>

<div align = right>
by Adorkable Dean<br>
at Nanjing,  Jiangsu, China
</div>


<p><br><br><br>
本文首发在Adorkable Dean‘s blog转载请注明原作者，<!--如果你觉得这篇文章对你有帮助或启发，也可以来请我[喝咖啡](支付宝图片)。-->如果你对这篇文章有更好的见解可以通过微信联系<a href="http://adorkabledean.github.io/adeanimages/wechat_image.png"><strong>我</strong></a>。</p>

<p>利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。
<br><br><br></p>

<h2>参考文章：</h2>

<p><a href="http://www.tairan.com/archives/4508/">打造轻量化的View Controller</a></p>

<p><a href="http://blog.csdn.net/ajrm0925/article/details/7431982/">ObjC的initialize和init</a></p>

<p><a href="http://www.wtoutiao.com/a/1342550.html">ViewController瘦身方法总结</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计项目中图片使用情况]]></title>
    <link href="http://adorkabledean.github.io/blog/20151027/tong-ji-xiang-mu-zhong-tu-pian-shi-yong-qing-kuang/"/>
    <updated>2015-10-27T16:32:49+08:00</updated>
    <id>http://adorkabledean.github.io/blog/20151027/tong-ji-xiang-mu-zhong-tu-pian-shi-yong-qing-kuang</id>
    <content type="html"><![CDATA[<h1>统计项目中图片使用情况</h1>

<p>随着项目开发推进和版本迭代，项目中总会存在一些无效的图片资源，这些无效图片往往会增加编译成本和包的大小。</p>

<blockquote><p>一个普通的iOS工程会有大约三分之一的图片是未使用的。</p></blockquote>

<p>常用的方法有：</p>

<p>1，利用工具；</p>

<p>2，利用脚本；</p>

<p>3，添加图片时候写图片名称的代码；</p>

<p>脚本&amp;工具的原理大概是这样，在工程中搜图片名称，如果没有使用这个图片名称的话，则认为这张图片没有被使用并列举出来。这种做法不太精准：</p>

<p>1，遇到用imageview做动画（即imageView.animationImages）时候，一般开发人员都会喜欢用for循环加入所有图片，这样就会导致已使用图片被列举出来；</p>

<p>2，使用不同资源包时候，如果两个资源包有相同名称，但是有个资源包中的图片没被使用，这样就会导致未被使用的没列举出来；</p>

<p>诸如此类情况有很多。有人会说用第三种方法，但是手动添加这样比较费时，即下面这种场景：</p>

<blockquote><p>例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p></blockquote>

<p>上面一段是<a href="http://nshipster.com/method-swizzling/"><code>Method Swizzling</code></a>中开篇的描述，确实人工手动添加难免会有漏掉，那么就要用苹果自带的方法集中处理。</p>

<p>我们可以通过<code>Method Swizzling</code>修改<code>UIImage</code>的调用方法，在<code>UIImage</code>中添加打印使用图片(或者路径)的方法，然后写到一个文件里，在项目结束时候将没有出现在文件中的图片删除即可（可以采用脚本删除，便捷准确）。</p>

<p>这种情况下，我们就可以写出如下<code>Method Swizzling</code>，如在代码所示：</p>

<pre>
<code>
#import "ADeanImage+Hook.h"
#import <objc/objc.h>
#import <objc/runtime.h>

@implementation UIImage (Hook)

+ (void)initialize
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        [self adeanImageHook];
    });
}

+ (void)adeanImageHook
{
    [self imageNameHook];
}

+ (void)imageNameHook  // 类方法调用方式
{
    Class class = object_getClass((id)self);
    SEL originalSelector = @selector(imageNamed:);
    SEL swizzledSelector = @selector(adean_imageNamed:);

    Method originalMethod = class_getClassMethod(class, originalSelector);
    Method swizzledMethod = class_getClassMethod(class, swizzledSelector);
    
    BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
    if (didAddMethod)
    {
        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    }
    else
    {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

+ (UIImage *)adean_imageNamed:(NSString *)name
{
    UIImage *image = [self adean_imageNamed:name];
    [self printImageNameToLocalWithImageName:name];
    return image;
}

+ (void)printImageNameToLocalWithImageName:(NSString *)name
{
#ifdef ADeanForTest
    {
        // 打印图片地址
        ADeanLog(@"adean_msg:  imagefile %@", IMAGEFILEFILE);
        FILE *fp;
        const char *imageFilePath =[IMAGEFILEFILE UTF8String];
        const char *cImageName = [[NSString stringWithFormat:@"%@\n", name] UTF8String];
        /*打开文件*/
        if((fp = fopen(imageFilePath, "a")) == NULL)
        {
            ADeanLog("文件打开出错，请检查文件是否存在\n");
        }
        else
        {
        }
        fputs(cImageName,fp);
        fclose(fp);
    }
#endif
}

@end
</code>
</pre>


<p><br>
这样只要在<code>Appdelegate</code>启动时候调用下<code>[UIImage initialize]</code>就可以将所有用到<code>imageNamed:</code>的图片都打印出来。
如果需要打印所有已使用图片，只需要将UIImage中所有的类方法和实例方法都<code>Method Swizzling</code>下。这样项目测试一遍就可以将所有已使用图片存到一张图片清单上，只要在用脚本语言删除项目中没在图片清单上的图片即可。
<br><br></p>

<h4>注：</h4>

<p>中文版的<a href="http://blog.jobbole.com/79580/">《Objective-C Runtime 运行时之四：Method Swizzling》</a>和<a href="http://www.cocoachina.com/industry/20140225/7880.html">《Method Swizzling》</a>漏掉了原著中的一段代码注释：</p>

<blockquote><pre><code> // When swizzling a class method, use the following:      
 // Class class = object_getClass((id)self);
 // ...
 // Method originalMethod = class_getClassMethod(class, originalSelector);
 // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);
</code></pre></blockquote>

<!--
4， AOP
-->


<p><br><br><br></p>

<div align = right>
by Adorkable Dean<br>
at Nanjing,  Jiangsu, China
</div>


<p><br><br><br>
本文首发在Adorkable Dean‘s blog转载请注明原作者，<!--如果你觉得这篇文章对你有帮助或启发，也可以来请我[喝咖啡](支付宝图片)。-->如果你对这篇文章有更好的见解可以通过微信联系<a href="http://adorkabledean.github.io/adeanimages/wechat_image.png"><strong>我</strong></a>。</p>

<p>利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。
<br><br><br></p>

<h4>参考文章：</h4>

<p><a href="http://blog.csdn.net/songhongri/article/details/21833069">如何删除xcode项目中不再使用的图片资源</a></p>

<p><a href="http://www.zhihu.com/question/20932106">有快捷的办法找到并删除 Xcode 工程中没用到的图片吗？</a></p>

<!--
[Method Swizzling和AOP(面向切面编程)实践](http://www.cocoachina.com/ios/20150120/10959.html)

[Aspects iOS的AOP面向切面编程的库](http://segmentfault.com/a/1190000003499895)
-->


<p><a href="http://www.cocoachina.com/industry/20140225/7880.html">Method Swizzling</a></p>

<p><a href="http://blog.jobbole.com/79580/">Objective-C Runtime 运行时之四：Method Swizzling</a></p>

<p><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息转发和NSUserDefaults的灵活使用]]></title>
    <link href="http://adorkabledean.github.io/blog/20151026/xiao-xi-zhuan-fa-he-nsuserdefaultsde-ling-huo-shi-yong/"/>
    <updated>2015-10-26T13:26:06+08:00</updated>
    <id>http://adorkabledean.github.io/blog/20151026/xiao-xi-zhuan-fa-he-nsuserdefaultsde-ling-huo-shi-yong</id>
    <content type="html"><![CDATA[<h1>消息转发和NSUserDefaults的灵活使用</h1>

<p>NSUserDefaults是轻量级本地数据存储的重要一部分，也是大家喜欢用来保存简单数据的一个主要途径。
但是NSUserDefaults的读取方式比较长：</p>

<pre>
<code>
    // NSString数据存储
    NSString *passWord = @"1234567";
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    [userDefaults setObject:passWord forKey:@"userPassWord"];
    [userDefaults synchronize];      
</code>
</pre>




<pre>
<code>
    // NSString数据读取
    NSString *passWord = @"";
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    passWord = [userDefaults stringForKey:@"userPassWord"];
</code>
</pre>


<p>如果当定义的变量多的时候，NSUserDefaults的代码量也会随着增多。例如在一个登录网络请求后，如果需要存储超过3个以上变量时：</p>

<pre>
<code>
        [[ADeanUserServiceManager sharedInstance] loginWithCompleteBlock:^(NSError *error, id result) {
        __strong __typeof(&*weakSelf)strongSelf = weakSelf;
        if (!strongSelf)
        {
            return;
        }
        if (error == nil)
        {
            [strongSelf hideToast];
            NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
            [userDefaults setObject:((ADeanUserServiceDto *)result).token forKey:@"token"];
            [userDefaults setObject:((ADeanUserServiceDto *)result).uid forKey:@"uid"];
            [userDefaults setObject:((ADeanUserServiceDto *)result).mobile forKey:@"mobile"];
            [userDefaults setObject:((ADeanUserServiceDto *)result).realName forKey:@"realName"];
            [userDefaults setObject:((ADeanUserServiceDto *)result).faceImageUrl forKey:@"faceImageUrl"];
            [userDefaults setObject:@YES forKey:@"isLogined"];
            [userDefaults synchronize];      
        }
        else
        {
            [strongSelf hideToast];
            [strongSelf displayToast:[error normErrorString]];
        }
    }];
</code>
</pre>


<p>部分地方还要加上防御性代码，例如：</p>

<pre>
<code>
    BOOL isLogined = NO;
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    isLogined = [[userDefaults stringForKey:@"isLogined"] boolValue];
    if  (isLogined) {
        // 登录
        if ([userDefaults stringForKey:@"realName"] != nil &&
            [userDefaults stringForKey:@"realName"].length > 0) {
            
            userNameLabel.text = [userDefaults stringForKey:@"realName"];
        }
        if ([userDefaults stringForKey:@"phone"] != nil &&
            [userDefaults stringForKey:@"phone"].length > 0) {
            
            userPhoneLabel.text = [userDefaults stringForKey:@"phone"];
        }
    }
</code>
</pre>


<p>有人会说在统一的地方对NSUserDefaults进行初始化，例如在：</p>

<pre>
<code>
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    [self initUserDefaultsValue];
    return YES;
}

- (void)initUserDefaultsValue {

    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    if ([userDefaults stringForKey:@"token"] != nil &&
        [userDefaults stringForKey:@"token"].length > 0) {
   
        [userDefaults setObject:@"" forKey:@"token"];
    }
    if ([userDefaults stringForKey:@"uid"] != nil &&
        [userDefaults stringForKey:@"uid"].length > 0) {
   
        [userDefaults setObject:@"" forKey:@"uid"];
    }
    ...
}
</code>
</pre>


<p>这样用法的NSUserDefaults就有违开发过程中一向的“代码简洁，节省输入需要的操作和时间”追求。有人会说可以使用“Xcode Code Snippets”，宏定义等便捷NSUserDefaults的操作。但是“Xcode Code Snippets”只能节省部分代码块的输入，而只针对单个Xcode，这样就意味着每个人都要这样用；宏定义的使用更多是防止Key错误，和为空判断简化，没法真正简化NSUserDefaults的使用。</p>

<p>综合分析下，NSUserDefaults使用繁琐主要是因为Get&amp;Set方法没有被简化。在Objective-C中，Runtime是一个很重要的东西：函数调用成为消息发送，即消息机制。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编译阶段，Objective-C可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。）。只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p>

<blockquote><p>关于消息机制可以参考： <a href="http://www.cocoachina.com/ios/20141018/9960.html">http://www.cocoachina.com/ios/20141018/9960.html</a></p></blockquote>

<p>我们在开发过程中也经常遇到这样的错误：</p>

<pre> 
<code>
[__NSCFNumber lowercaseString]: unrecognized selector sent to  
instance 0x87  
*** Terminating app due to uncaught exception  
'NSInvalidArgumentException', reason: '-[__NSCFNumber  
lowercaseString]: unrecognized selector sent to instance 0x87' 
</code>
</pre>


<p>这个有可能是方法找不到。</p>

<p>上面这段异常信息是由NSObject的“doesNotRecognizeSelector:”方法所抛出的，此异常表明：消息接收者的类型是<em> </em>NSCFNumber，而该接收者无法理解名为lowercaseString的选择。</p>

<p>消息转发中， <strong>+ (BOOL)resolveInstanceMethod:(SEL)selector</strong> 和<strong>- (id)forwardingTargetForSelector:(SEL)selector</strong> 是两个需要覆盖的函数。
<em>methodSignatureForSelector:</em>的作用在于为另一个类实现的消息创建一个有效的方法签名，必须实现，并且返回不为空的methodSignature，否则会crash。
<em>forwardInvocation:</em>将选择器转发给一个真正实现了该消息的对象。</p>

<pre>
<code>
- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector
{
    NSString *sel = NSStringFromSelector(selector);
    if ([sel rangeOfString:@"set"].location == 0)
    {
        return [NSMethodSignature signatureWithObjCTypes:"v@:@"];
    }
    else
    {
        return [NSMethodSignature signatureWithObjCTypes:"@@:"];
    }
}
 
- (void)forwardInvocation:(NSInvocation *)invocation
{
    NSString *key = NSStringFromSelector([invocation selector]);
    if ([key rangeOfString:@"set"].location == 0)
    {
        key= [[key substringWithRange:NSMakeRange(3, [key length]-4)] lowercaseString];
        NSString *obj;
       [invocation getArgument:&objatIndex:2];
        [_propertiesDict setObject:obj forKey:key];
    }
    else
    {
        NSString *obj = [_propertiesDict objectForKey:key];
       [invocation setReturnValue:&obj];
    }
} 
</code>
</pre>


<blockquote><p>上述函数解释可以参考 <a href="http://blog.sina.com.cn/s/blog_8c87ba3b0102v006.html">http://blog.sina.com.cn/s/blog_8c87ba3b0102v006.html</a></p></blockquote>

<p>这时候我们就可以将NSUserDefaults重新定义，这样就可以简化NSUserDefaults的使用：</p>

<pre>
<code>
//  UserDefaultConfig.h

#define dEverLaunched         NSStringFromSelector(@selector(everLaunched)) 


@interface UserDefaultConfig : NSObject
{
    NSUserDefaults *defaults;
}

+ (UserDefaultConfig *)currentConfig;

@property (readwrite, strong) NSUserDefaults *defaults;
@property (nonatomic, readwrite, strong) NSNumber *everLaunched; // 是否首次登陆

@end
---------------------------------------------------------
---------------------------------------------------------
// UserDefaultConfig.m
#import "UserDefaultConfig.h"

@implementation UserDefaultConfig

@synthesize defaults;
@dynamic everLaunched;

-(id) init
{
    if(!(self = [super init]))
    {
        return self;
    }
    self.defaults = [NSUserDefaults standardUserDefaults];
    
    [self.defaults registerDefaults:[NSDictionary dictionaryWithObjectsAndKeys:
                                     @NO, dEverLaunched,
                                     nil]];
    return self;
}

-(void) dealloc
{
    self.defaults = nil;
    self.everLaunched = nil;
}

+ (UserDefaultConfig *)currentConfig
{
    static UserDefaultConfig *instance;
    if(!instance)
    {
        instance = [[UserDefaultConfig alloc] init];
    }
    return instance;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    if ([NSStringFromSelector(aSelector) hasPrefix:@"set"])
    {
        return [NSMethodSignature signatureWithObjCTypes:"v@:@"];
    }
    return [NSMethodSignature signatureWithObjCTypes:"@@:"];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    NSString *selector = NSStringFromSelector(anInvocation.selector);
    if ([selector hasPrefix:@"set"])
    {
        NSRange firstChar, rest;
        firstChar.location  = 3;
        firstChar.length    = 1;
        rest.location       = 4;
        rest.length         = selector.length - 5;
        
        selector = [NSString stringWithFormat:@"%@%@", [[selector substringWithRange:firstChar] lowercaseString], [selector substringWithRange:rest]];
        id value;
        [anInvocation getArgument:&value atIndex:2];
        if ([value isKindOfClass:[NSArray class]]) 
        {
            [self.defaults setObject:[NSKeyedArchiver archivedDataWithRootObject:value] forKey:selector];
        }
        else
        {
            [self.defaults setObject:value forKey:selector];
        }
    }
    else
    {
        id value = [self.defaults objectForKey:selector];
        if ([value isKindOfClass:[NSData class]]) 
        {
            value = [NSKeyedUnarchiver unarchiveObjectWithData:value];
        }
        [anInvocation setReturnValue:&value];
    }
}

@end
</code>
</pre>


<p>这样在外面直接可以使用[UserDefaultConfig currentConfig].everLaunched了。
<br><br><br></p>

<div align = right>
by Adorkable Dean<br>
at Nanjing,  Jiangsu, China
</div>


<p><br><br><br>
本文首发在Adorkable Dean‘s blog转载请注明原作者，<!--如果你觉得这篇文章对你有帮助或启发，也可以来请我[喝咖啡](支付宝图片)。-->如果你对这篇文章有更好的见解可以通过微信联系<a href="http://adorkabledean.github.io/adeanimages/wechat_image.png"><strong>我</strong></a>。</p>

<p>利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。
<br><br><br></p>

<h4>参考文章：</h4>

<p><a href="http://book.51cto.com/art/201403/432146.htm">第12条：理解消息转发机制（1）</a></p>

<p><a href="http://www.cocoachina.com/ios/20141018/9960.html">Objective-C总Runtime的那点事儿（一）消息机制</a></p>

<p><a href="http://blog.sina.com.cn/s/blog_8c87ba3b0102v006.html">使用methodSignatureForSelector与forwardInvocation实现消息转发</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发注意事项随手记]]></title>
    <link href="http://adorkabledean.github.io/blog/20151013/17-46-11-kai-fa-zhu-yi-shi-xiang-sui-shou-ji/"/>
    <updated>2015-10-13T17:46:11+08:00</updated>
    <id>http://adorkabledean.github.io/blog/20151013/17-46-11-kai-fa-zhu-yi-shi-xiang-sui-shou-ji</id>
    <content type="html"><![CDATA[<h1>开发注意事项随手记</h1>

<p>在开发过程中踩过各种坑，开篇帖子专门记录已经踩过的各种坑。</p>

<blockquote><p>鼓励大家做完一些东西，都能写一些文章。比如，sdk整个架构讨论的过程。实验过的各种方案，最终的选择方法。这些思考的过程都可以写成文章发表
每次研究完一个东西，都可以整理记录下来</p></blockquote>

<h4>1. 防御性代码</h4>

<ol>
<li><p>将objectAtIndex这种很容易crash的封装。</p></li>
<li><p>判断数组是否为空，NSString/NSDictionary，判断i是否数组越界。</p></li>
<li><p>对基本释放进行封装，比如最基本的释放，NSTimer释放，View释放，Tableview释放，HTTP释放。<em>ARC中释放部分忽略</em></p></li>
<li><p>非空判断，采用isEqual。</p></li>
</ol>


<h4>2. 名称定义</h4>

<ol>
<li><p>不管他们是Cocoa自带还是你自己创建的，类名需要带上前缀且必须要大写。</p></li>
<li><p>变量名以小写字母开始，往后每出现一个新单词，该单词首字母大写（驼峰原则）。</p></li>
<li><p>规范化，宏定义放在一个.h文件中，全局变量放在一个.h中。<em>忽略此做法，枚举方法可以按照不同类分别存放</em></p></li>
<li><p>类名如何定义，函数名如何定义，变量名如何定义。宏名字全部使用大写字母。通知的定义统一放在一个.h文件中。</p></li>
<li><p>网络返回的基本error定义统一放在一个.h文件中。这些.h声明放在一个.h中，统一调用，提高编译效率。</p></li>
</ol>


<h4>3. 提高开发效率</h4>

<ol>
<li><p>一些预处理放在统一处，放在view初始化之后，比方说文件夹的创建，统计数据处理，当然了统计的处理是为了统计什么模块用的比较多，什么按钮用的比较多，找出用户的习惯。</p></li>
<li><p>创建基本的rootviewcontroller &amp; rootView。<em>推荐多使用组合分类，少使用继承</em></p></li>
<li><p>采用的判断：因为登录之类的，需要将nsstring的基本判抽出来，用统一的类实现处理。对于tablewviewcell，一般采用自定义方式。tableview处理，一般采用plist，处理起来简单方便。</p></li>
<li><p>适当注释，因为部分类名可以涵盖注释的作用。一般多用#prama来区分。 <em>可以使用code snippets</em></p></li>
<li><p>单元测试：.m采用profile analyze 内存分析</p></li>
</ol>


<h4>4. 代码构建</h4>

<ol>
<li><p>可扩展性</p></li>
<li><p>可移植性</p></li>
<li><p>良好的文档</p></li>
<li><p>生命周期管理：最初学习的是Three20中，将类中全局变量放在自己的get方法中初始化。<em>即采用懒加载</em></p></li>
</ol>


<h4>5. 提高效率</h4>

<ol>
<li><p>画流程图</p></li>
<li><p>国际化语言统一定义，采用脚本语言统一替换。避免人工查找费时。</p></li>
<li><p>尽量不暴露变量，即尽量私有化。<em>采用readonly&amp;readwrite限制变量安全性</em></p></li>
<li><p>开发完成后，将写详细设计书。可以总结出一些经验教训，在下一版本中得到改善。</p></li>
</ol>


<h4>6. 其他</h4>

<ol>
<li><p>写文件采用的是NSFileHandle，可以追加。当然，还可以用C中的基本处理，fwrite，FileStream，主要是服务器不是分段的，也没有返回长度，所以才一次性。没有断点续传的功能。</p></li>
<li><p>代码强调分层 包装 抽象。数据库  分层  dao xdao基本增删改查 bo。请求也是层层封装的。比方说，Pan中有很多操作，现将基本的http请求定义好，然后不同的文件（夹）的请求在此基础上定义。最后到Controller那边处理这些。</p></li>
<li><p>Model，一般是封装在统一个Dto中。这样有些操作的处理传参就不用写很多，直接一个Dto即可。
XMPP有些扩展，在调用原有的基础上，进行扩展。</p></li>
<li><p>关于数据库使用，fmdb每秒60次读写 ，文件每秒200次左右，写文件效率高。图片给路径形式。</p></li>
</ol>


<p><br><br><br></p>

<div align = right>
by Adorkable Dean<br>
at Nanjing,  Jiangsu, China
</div>


<p><br><br><br>
本文首发在Adorkable Dean‘s blog转载请注明原作者，<!--如果你觉得这篇文章对你有帮助或启发，也可以来请我[喝咖啡](支付宝图片)。-->如果你对这篇文章有更好的见解可以通过微信联系<a href="http://adorkabledean.github.io/adeanimages/wechat_image.png"><strong>我</strong></a>。</p>

<p>利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。
<br><br><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[readonly的使用支招]]></title>
    <link href="http://adorkabledean.github.io/blog/20151013/15-38-44-readonlyde-shi-yong-zhi-zhao/"/>
    <updated>2015-10-13T15:38:44+08:00</updated>
    <id>http://adorkabledean.github.io/blog/20151013/15-38-44-readonlyde-shi-yong-zhi-zhao</id>
    <content type="html"><![CDATA[<h1>readonly的使用支招</h1>

<p>最近在开发支付SDK，支付过程中订单号、银行卡号等重要东西对外只能只读，所以这些变量就不得不设置为readonly属性。</p>

<blockquote><p>readonly：这个属性变量就是表明变量只有可读方法，也就是说，你只能使用它的get 方法和带_的成员对象，而没法对其set。readonly保证了变量的安全性（访问的安全性）。</p></blockquote>

<p>但是，支付过程中订单号、银行卡号还是通过外部传入进来的（这些是包装在一个或者多个Model中的），这样就要设置专门的类方法/实例方法进行赋值了。</p>

<p>下面是PayCardInfoDto.h</p>

<pre>
<code>
@interface PayCardInfoDto : NSObject 
 
/**
*  银行卡号.
*/
@property (nonatomic, readonly, nullable) NSString *number;

/**
*  银行卡Id. 即银行卡在服务器系统里对应的Id.
*/
@property (nonatomic, readonly, nullable) NSString *cardId;

- (nonnull instancetype)initWithAttributeDictionary:(nonnull NSDictionary *)attributeDictionary;

@end
</code>
</pre>


<p>下面是PayCardInfoDto.m</p>

<pre>
<code>
#import "PayCardInfoDto.h"
@implementation PayCardInfoDto

- (instancetype)init
{
    self = [super init];
    if (self)
    {
    }
    return self;
}

- (instancetype)initWithAttributeDictionary:(NSDictionary *)attributeDictionary
{
    self = [self init];
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    [attributeDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id obj, __unused BOOL *stop) {
    if (obj != [NSNull null])
    {
        dict[key] = obj;
    }
    }];
    if (self)
    {
        _cardId = dict[@"id"];
        _number = dict[@"number"];
    }
    return self;
}
</code>
</pre>


<p>这样就可以防止外部直接修改变量值了。此时有些人喜欢对.m文件进行如下修改，即：</p>

<pre>
<code>#import "PayCardInfoDto.h"

@interface PayCardInfoDto : NSObject 

@property (nonatomic, readwrite, nullable) NSString *number;
@property (nonatomic, readwrite, nullable) NSString *cardId;

@end

@implementation PayCardInfoDto

- (instancetype)init
{
    self = [super init];
    if (self)
    {
    }
    return self;
}

- (instancetype)initWithAttributeDictionary:(NSDictionary *)attributeDictionary
{
    //相同部分省略...
    return self;
}
</code>
</pre>


<p>这样其实保证了，外部只能对此Model只读，Model内部可以修改。
如果如下写，也是可以的。因为默认是readwrite属性。</p>

<pre>
<code>
@interface PayCardInfoDto : NSObject 

@property (nonatomic, nullable) NSString *number;
@property (nonatomic, nullable) NSString *cardId;

@end
</code>
</pre>


<p><br><br><br></p>

<div align = right>
by Adorkable Dean<br>
at Nanjing,  Jiangsu, China
</div>


<p><br><br><br>
本文首发在Adorkable Dean‘s blog转载请注明原作者，<!--如果你觉得这篇文章对你有帮助或启发，也可以来请我[喝咖啡](支付宝图片)。-->如果你对这篇文章有更好的见解可以通过微信联系<a href="http://adorkabledean.github.io/adeanimages/wechat_image.png"><strong>我</strong></a>。</p>

<p>利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。
<br><br><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在前面]]></title>
    <link href="http://adorkabledean.github.io/blog/20150603/xie-zai-qian-mian/"/>
    <updated>2015-06-03T15:58:33+08:00</updated>
    <id>http://adorkabledean.github.io/blog/20150603/xie-zai-qian-mian</id>
    <content type="html"><![CDATA[<h1>写在前面</h1>

<p>@(随手)[AdorkableDean|生活感悟]<br>
2014年，不是本命年，但是被折磨了一年。本来计划的很多事情都停下来了；很多想做的事情都不得不放弃了；技术又退步了不少。唉~ <br>
2015年，重新回归学习，重新回到正轨。<br>
<br><br><br></p>

<div align = right>
by Adorkable Dean<br>
at Nanjing,  Jiangsu, China
</div>


<p><br><br><br>
本文首发在Adorkable Dean‘s blog转载请注明原作者，<!--如果你觉得这篇文章对你有帮助或启发，也可以来请我[喝咖啡](支付宝图片)。-->如果你对这篇文章有更好的见解可以通过微信联系<a href="http://adorkabledean.github.io/adeanimages/wechat_image.png"><strong>我</strong></a>。</p>

<p>利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。
<br><br><br></p>
]]></content>
  </entry>
  
</feed>
